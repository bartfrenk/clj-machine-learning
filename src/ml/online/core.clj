(ns ml.online.core
  (:gen-class)
  (:require [clojure.core.matrix :as m]
            [clojure.core.matrix.protocols :as mp]
            [kixi.stats.distribution :as d]
            [incanter.charts :as c]
            [incanter.core :as i])
  (:import [java.util Random]))


(m/set-current-implementation :vectorz)

(def m (m/matrix [[1 2 3] [4 5 6] [7 8 9]]))

(m/mmul m m)


(defn sample-mean
  "Transducer to compute the online (arithmetic) sample mean."
  [xf]
  (let [state (volatile! [0 0])]
    (fn
      ([] (xf))
      ([result] (xf result))
      ([result ^double input]
       (let [[k x-bar] @state
             k* (inc k)
             x-bar* (+ x-bar (* (/ k*) (- input x-bar)))
             ]
         (vreset! state [k* x-bar*])
         (xf result x-bar*))))))


(defn sample-variance
  "Transducer to compute the online sample variance. Uses Wellford's method."
  [xf]
  (let [state (volatile! [0 0 0])]
    (fn
      ([] (xf))
      ([result] (xf result))
      ([result ^double input]
       (let [[k x-bar ss] @state
             d (- input x-bar)
             k* (inc k)
             x-bar* (+ x-bar (* (/ k*) (- input x-bar)))
             ss* (+ ss (* d (- input x-bar*)))]
         (vreset! state [k* x-bar* ss*])
         (if (pos? k)
           (xf result (/ ss* k))
           (xf result)))))))


(defn online
  "Function for creating online statistics.

  This works as a simple state machine, where a state transition is initiated by
  putting a value. The new state is computed by applying `f` to the current
  state and the new input. A value is then generated by applying `g` to the new
  state. The `init` value is the initial state.

  For example, the online mean is expressed as (online f / [0 0]), with f equal
  to (fn [[s n] x] [(+ s x) (inc n)].
  "
  [f g init]
  (fn [xf]
    (let [state (volatile! init)]
      (fn
        ([] (xf))
        ([result] (xf result))
        ([result input]
         (let [current @state
               next (f current input)]
           (vreset! state next)
           (xf result (g next))))))))


(defn linear-regression
  "Bayesian linear regression with Gaussian prior on the weights.
  Updates are a pair of predictors and targets, where the predictors are given
  as the rows of a matrix of size m x n, and the target as a matrix of size 1 x m."
  [beta {:keys [mu cov] :as prior}]
  (fn
    [xf]
    (let [state (volatile! prior)]
      (fn
        ([] (xf))
        ([result] (xf result))
        ([result [predictors targets]]
         (let [{m0 :mu S0 :cov} @state
               predictors-t (m/transpose predictors)
               S0-inv (m/inverse S0)
               SN-inv (m/add S0-inv
                             (m/mmul predictors-t
                                     predictors
                                     beta))
               SN (m/inverse SN-inv)
               mN (m/mmul SN
                          (m/add (m/mmul S0-inv m0)
                                 (m/mmul beta predictors-t targets)))]
           (vreset! state {:mu mN :cov SN})
           (xf result [mN SN])))))))
